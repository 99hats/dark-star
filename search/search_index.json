{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dark Star Dark Star is a simple web framework built on top of Starlette that prioritises server-side rendering with templates. The vast majority of functionality is delegated to Starlette - Dark Star helps you organise your code and keeps your code next to your templates. Installation Install with pip : pip install dark-star Example Project layout my_app.py # The main application file routes/ index.html # The root template - inherited by other templates users.py # A template file that maps to the /users/ url users/ {profile}.py # A template that maps to the /user/{profile}/ url # and lets the code access the value of `profile` Example Template File The following example shows how code and templates live together: profile = request.path_params.get(\"profile\") \"\"\" {% extends 'index.html' %} Hello {profile} - here are your account details ... \"\"\" All templates get passed the request parameter as per Starlette's normal routes. The template is then included as a triple-quoted string at the end of the file. All variables defined in the code will be available in the template for use when rendering. Another example: users = Users.objects.all() \"\"\" {% extends 'index.html' %} <ul> {% for user in users %} <li>{{user}}</li> {% endfor %} </ul> \"\"\" Here the view function uses a Users object from an ORM to fetch a list of users from the database. These are then listed in the template. The Users object can be imported locally in the function, or in the my_app.py file at the root of the project. Anything imported in the my_app file is made available to all view functions.","title":"Dark Star"},{"location":"#dark-star","text":"Dark Star is a simple web framework built on top of Starlette that prioritises server-side rendering with templates. The vast majority of functionality is delegated to Starlette - Dark Star helps you organise your code and keeps your code next to your templates.","title":"Dark Star"},{"location":"#installation","text":"Install with pip : pip install dark-star","title":"Installation"},{"location":"#example-project-layout","text":"my_app.py # The main application file routes/ index.html # The root template - inherited by other templates users.py # A template file that maps to the /users/ url users/ {profile}.py # A template that maps to the /user/{profile}/ url # and lets the code access the value of `profile`","title":"Example Project layout"},{"location":"#example-template-file","text":"The following example shows how code and templates live together: profile = request.path_params.get(\"profile\") \"\"\" {% extends 'index.html' %} Hello {profile} - here are your account details ... \"\"\" All templates get passed the request parameter as per Starlette's normal routes. The template is then included as a triple-quoted string at the end of the file. All variables defined in the code will be available in the template for use when rendering. Another example: users = Users.objects.all() \"\"\" {% extends 'index.html' %} <ul> {% for user in users %} <li>{{user}}</li> {% endfor %} </ul> \"\"\" Here the view function uses a Users object from an ORM to fetch a list of users from the database. These are then listed in the template. The Users object can be imported locally in the function, or in the my_app.py file at the root of the project. Anything imported in the my_app file is made available to all view functions.","title":"Example Template File"},{"location":"htmx/","text":"Working with htmx Dark Star includes functionality to make working with htmx easier. In particular, it includes a piece of middleware to allow access to the request.state.htmx variable, which can be used in functions and templates to test whether a request came from htmx. Example Template File In the following example, the template will only extend index.html if the request is not from htmx. profile = request.path_params.get(\"profile\") \"\"\" {% if request.state.htmx %}{% extends 'index.html' %}{% endif %} Hello {{profile}} - here are your account details ... \"\"\"","title":"Working with htmx"},{"location":"htmx/#working-with-htmx","text":"Dark Star includes functionality to make working with htmx easier. In particular, it includes a piece of middleware to allow access to the request.state.htmx variable, which can be used in functions and templates to test whether a request came from htmx.","title":"Working with htmx"},{"location":"htmx/#example-template-file","text":"In the following example, the template will only extend index.html if the request is not from htmx. profile = request.path_params.get(\"profile\") \"\"\" {% if request.state.htmx %}{% extends 'index.html' %}{% endif %} Hello {{profile}} - here are your account details ... \"\"\"","title":"Example Template File"},{"location":"routes/","text":"Routes The key feature that Dark Star offers is using the filesystem for routing. I.e. your file paths will become your application routes. Route file format Route files are simple python files. Any python code they contain will be wrapped into a view function and passed to Starlette. For example, the following code: user = request.path_params[\"user\"] Will get converted into the following function: def some_random_function_name(request): user = request.path_params[\"user\"] return templates.TemplateResponse(\"<path_to_the_python_file>\", {...}) The function's name is based off a hash of the file path, and so should be considered random to all intents and purposes. The return value is added to the end of all functions, so it is important that a template also be defined in the file. Templates are defined by adding a triple-quoted string to the end of the file. For example: user = request.path_params[\"user\"] \"\"\" {% extends 'index.html' %} Hello {{user}} - welcome to Dark Star \"\"\" The user variable is passed into the template and can be used as shown.","title":"Routes"},{"location":"routes/#routes","text":"The key feature that Dark Star offers is using the filesystem for routing. I.e. your file paths will become your application routes.","title":"Routes"},{"location":"routes/#route-file-format","text":"Route files are simple python files. Any python code they contain will be wrapped into a view function and passed to Starlette. For example, the following code: user = request.path_params[\"user\"] Will get converted into the following function: def some_random_function_name(request): user = request.path_params[\"user\"] return templates.TemplateResponse(\"<path_to_the_python_file>\", {...}) The function's name is based off a hash of the file path, and so should be considered random to all intents and purposes. The return value is added to the end of all functions, so it is important that a template also be defined in the file. Templates are defined by adding a triple-quoted string to the end of the file. For example: user = request.path_params[\"user\"] \"\"\" {% extends 'index.html' %} Hello {{user}} - welcome to Dark Star \"\"\" The user variable is passed into the template and can be used as shown.","title":"Route file format"}]}