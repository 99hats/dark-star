{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dark Star Dark Star is a simple web framework built on top of Starlette that prioritises server-side rendering with templates. The vast majority of functionality is delegated to Starlette - Dark Star helps you organise your code and keeps your code next to your templates. Installation Install with pip : pip install darkstar Create a new app: python -m darkstar create-app # or darkstar create-app Starter Application Dark Star uses default values for its directories, so getting started is very easy. If you didn't use the CLI's create-app command then create an app.py file with the following content: from darkstar.applications import DarkStar app = DarkStar() The above code will assume your routes are in the routes directory and static files are in the static directory. You can then run your application using an ASGI server, such as uvircorn: pip install uvicorn[standard] # if not already installed uvicorn app:app Example Project layout my_app.py # The main application file static/ # Static files under /static/ routes/ index.html # The root template - inherited by other templates users.py # A template file that maps to the /users/ url users/ {profile}.py # A template that maps to the /user/{profile}/ url # and lets the code access the value of `profile` Example Template File Template files are regular python files which contain the template at the end as a triple-quoted string. profile = request.path_params.get(\"profile\") \"\"\" {% extends 'index.html' %} Hello {profile} - here are your account details ... other content \"\"\" All templates get passed the request parameter as per Starlette's normal routes. The template is then included as a triple-quoted string at the end of the file. All variables defined in the code will be available in the template for use when rendering. Another example: users = Users.objects.all() \"\"\" {% extends 'index.html' %} <ul> {% for user in users %} <li>{{user}}</li> {% endfor %} </ul> \"\"\" Here the view function uses a Users object from an ORM to fetch a list of users from the database. These are then listed in the template. The Users object can be imported locally in the function, or in the my_app.py file at the root of the project. Anything imported in the my_app file is made available to all view functions.","title":"Dark Star"},{"location":"#dark-star","text":"Dark Star is a simple web framework built on top of Starlette that prioritises server-side rendering with templates. The vast majority of functionality is delegated to Starlette - Dark Star helps you organise your code and keeps your code next to your templates.","title":"Dark Star"},{"location":"#installation","text":"Install with pip : pip install darkstar Create a new app: python -m darkstar create-app # or darkstar create-app","title":"Installation"},{"location":"#starter-application","text":"Dark Star uses default values for its directories, so getting started is very easy. If you didn't use the CLI's create-app command then create an app.py file with the following content: from darkstar.applications import DarkStar app = DarkStar() The above code will assume your routes are in the routes directory and static files are in the static directory. You can then run your application using an ASGI server, such as uvircorn: pip install uvicorn[standard] # if not already installed uvicorn app:app","title":"Starter Application"},{"location":"#example-project-layout","text":"my_app.py # The main application file static/ # Static files under /static/ routes/ index.html # The root template - inherited by other templates users.py # A template file that maps to the /users/ url users/ {profile}.py # A template that maps to the /user/{profile}/ url # and lets the code access the value of `profile`","title":"Example Project layout"},{"location":"#example-template-file","text":"Template files are regular python files which contain the template at the end as a triple-quoted string. profile = request.path_params.get(\"profile\") \"\"\" {% extends 'index.html' %} Hello {profile} - here are your account details ... other content \"\"\" All templates get passed the request parameter as per Starlette's normal routes. The template is then included as a triple-quoted string at the end of the file. All variables defined in the code will be available in the template for use when rendering. Another example: users = Users.objects.all() \"\"\" {% extends 'index.html' %} <ul> {% for user in users %} <li>{{user}}</li> {% endfor %} </ul> \"\"\" Here the view function uses a Users object from an ORM to fetch a list of users from the database. These are then listed in the template. The Users object can be imported locally in the function, or in the my_app.py file at the root of the project. Anything imported in the my_app file is made available to all view functions.","title":"Example Template File"},{"location":"cli/","text":"Dark Star CLI Dark Star comes with a CLI that helps you perform basic tasks. Run it using the command darkstar . $ darkstar Usage: cli [OPTIONS] COMMAND [ARGS]... Dark Star - a web framework based on Starlette Options: --help Show this message and exit. Commands: create-app new-route create-app create-app takes a directory where a new app and directory structure will be created. $ darkstar create-app --help Usage: cli create-app [OPTIONS] DIRECTORY new-route new-route takes a route path and creates the python file in the correct location. It will also parse any path parameters and add code to extract them from the request.","title":"CLI"},{"location":"cli/#dark-star-cli","text":"Dark Star comes with a CLI that helps you perform basic tasks. Run it using the command darkstar . $ darkstar Usage: cli [OPTIONS] COMMAND [ARGS]... Dark Star - a web framework based on Starlette Options: --help Show this message and exit. Commands: create-app new-route","title":"Dark Star CLI"},{"location":"cli/#create-app","text":"create-app takes a directory where a new app and directory structure will be created. $ darkstar create-app --help Usage: cli create-app [OPTIONS] DIRECTORY","title":"create-app"},{"location":"cli/#new-route","text":"new-route takes a route path and creates the python file in the correct location. It will also parse any path parameters and add code to extract them from the request.","title":"new-route"},{"location":"htmx/","text":"Working with htmx Dark Star includes functionality to make working with htmx easier. In particular, it includes a piece of middleware to allow access to the request.state.htmx variable, which can be used in functions and templates to test whether a request came from htmx. Example Template File In the following example, the template will only extend index.html if the request is not from htmx. profile = request.path_params.get(\"profile\") \"\"\" {% if request.state.htmx %}{% extends 'index.html' %}{% endif %} Hello {{profile}} - here are your account details ... \"\"\"","title":"htmx"},{"location":"htmx/#working-with-htmx","text":"Dark Star includes functionality to make working with htmx easier. In particular, it includes a piece of middleware to allow access to the request.state.htmx variable, which can be used in functions and templates to test whether a request came from htmx.","title":"Working with htmx"},{"location":"htmx/#example-template-file","text":"In the following example, the template will only extend index.html if the request is not from htmx. profile = request.path_params.get(\"profile\") \"\"\" {% if request.state.htmx %}{% extends 'index.html' %}{% endif %} Hello {{profile}} - here are your account details ... \"\"\"","title":"Example Template File"},{"location":"routes/","text":"Routes The key feature that Dark Star offers is using the filesystem for routing. I.e. your file paths will become your application routes. Route file format Route files are python files. Any python code they contain will be wrapped into a view function and passed to Starlette. For example, the following code: user = request.path_params[\"user\"] Will get converted into the following function: def some_random_function_name(request): user = request.path_params[\"user\"] return templates.TemplateResponse(\"<path_to_the_python_file>\", {...}) The function's name is based off a hash of the file path, and so should be considered random to all intents and purposes. The return value is added to the end of all functions, so it is important that a template also be defined in the file. Templates are defined by adding a triple-quoted string to the end of the file. For example: user = request.path_params[\"user\"] \"\"\" {% extends 'index.html' %} Hello {{user}} - welcome to Dark Star \"\"\" The user variable is passed into the template and can be used as shown. Route methods and name If you want to specify methods for a route rather than the default GET , then you can use a special comment at the top of the file. The following example shows a route that accepts both GET and POST requests: # methods=\"GET, POST\" if request.method == \"POST\": .... # process POST request elif request.method == \"GET\": .... # process GET request The methods need to be specified as a comma-separated list in a double-quoted string. Similarly, the route's name can be specified in the same comment using the name=<name> syntax. The following example shows a method named registration-form that accepts GET and POST requests: # methods=\"GET, POST\" name=\"registration-form\" if request.method == \"POST\": .... # process POST request elif request.method == \"GET\": .... # process GET request The name parameter is used when you want to obtain the url for a route using the url_for helper. See the Starlette docs for more information.","title":"Routes"},{"location":"routes/#routes","text":"The key feature that Dark Star offers is using the filesystem for routing. I.e. your file paths will become your application routes.","title":"Routes"},{"location":"routes/#route-file-format","text":"Route files are python files. Any python code they contain will be wrapped into a view function and passed to Starlette. For example, the following code: user = request.path_params[\"user\"] Will get converted into the following function: def some_random_function_name(request): user = request.path_params[\"user\"] return templates.TemplateResponse(\"<path_to_the_python_file>\", {...}) The function's name is based off a hash of the file path, and so should be considered random to all intents and purposes. The return value is added to the end of all functions, so it is important that a template also be defined in the file. Templates are defined by adding a triple-quoted string to the end of the file. For example: user = request.path_params[\"user\"] \"\"\" {% extends 'index.html' %} Hello {{user}} - welcome to Dark Star \"\"\" The user variable is passed into the template and can be used as shown.","title":"Route file format"},{"location":"routes/#route-methods-and-name","text":"If you want to specify methods for a route rather than the default GET , then you can use a special comment at the top of the file. The following example shows a route that accepts both GET and POST requests: # methods=\"GET, POST\" if request.method == \"POST\": .... # process POST request elif request.method == \"GET\": .... # process GET request The methods need to be specified as a comma-separated list in a double-quoted string. Similarly, the route's name can be specified in the same comment using the name=<name> syntax. The following example shows a method named registration-form that accepts GET and POST requests: # methods=\"GET, POST\" name=\"registration-form\" if request.method == \"POST\": .... # process POST request elif request.method == \"GET\": .... # process GET request The name parameter is used when you want to obtain the url for a route using the url_for helper. See the Starlette docs for more information.","title":"Route methods and name"}]}